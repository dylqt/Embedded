C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/03/2016 08:56:23 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE STC15_OLED
OBJECT MODULE PLACED IN stc15_oled.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE stc15_oled.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "stc15_oled.h"
   2          
   3          void InitOled()
   4          {
   5   1        //  6.1  CS#  片选  配置 强输出。
   6   1        //  6.2  D/C#  数据或命令 选择    配置 强输出。
   7   1        //  6.3  E/RD#  读写使能 或读   配置 强输出。
   8   1        //  6.4  R/W# 读写选择 或 写    配置 强输出。
   9   1        P2M1 = 0x00;
  10   1        P2M0 = 0xff;  
  11   1        
  12   1        BS1_OLED = 0; 
  13   1        BS2_OLED = 0; //BS1 BS2  配置 强输出 ；都拉高 ；选择 80xx 总线。  00 选择spi
  14   1        
  15   1        //6.5  D0~D7  数据总线   写  配置 强输出；读配置 输入带上拉电阻。
  16   1        //P7M1 &= ~0x80;  // D0 P7.7
  17   1        //P7M0 |= 0x80;
  18   1        //P4M1 &= ~0x30;  // D1 P4.5
  19   1        //P4M0 |= 0x30; // D2 P4.6
  20   1        //P0M1 &= ~0x1F;// D3 P0.0
  21   1        //P0M0 |= 0x1F;// D4 P0.1
  22   1        // D5 P0.2
  23   1        // D6 P0.3
  24   1        // D7 P0.4
  25   1      
  26   1        //P2M1 &= ~0x80;  // SDIN P2.7
  27   1        //P2M0 |= 0x80;
  28   1      
  29   1        P7M1 &= ~0x10;  // SCLK P7.4
  30   1        P7M0 |= 0x10;
  31   1      
  32   1      }
  33          
  34          // ------------------------------模拟 SPI ----------------------------------------------
  35          void uDelay(unsigned char t)
  36          {   
  37   1           while(t--);
  38   1      }
  39          
  40          
  41          void WRByte(unsigned char dat,unsigned char bIsCmd) //写完一字节,column会自增
  42          {
  43   1          unsigned char i=0x80; 
  44   1           CS_OLED = 0;   // ChipSelected(); 
  45   1           if(bIsCmd == 1) 
  46   1           {
  47   2            DC_OLED = 0;  // CmdInput();
  48   2           }else   
  49   1           {
  50   2            DC_OLED = 1;  // DataInput();
  51   2           }
  52   1           for(;i>0;i>>=1) //OLED从字节的高位D7输入,至到D0 -- SPI模拟
  53   1           {
  54   2             SCLK_OLED = 0; // SCLK.low();  
  55   2             SDIN_OLED = i & dat; // SDIN.set(i&dat);      
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/03/2016 08:56:23 PAGE 2   

  56   2             uDelay(15);
  57   2             SCLK_OLED = 1; // SCLK.high();      
  58   2             uDelay(15);          
  59   2           }
  60   1           SCLK_OLED = 0;
  61   1           SDIN_OLED = 1;
  62   1           uDelay(15);
  63   1          SCLK_OLED = 1; // SCLK.high(); 
  64   1          
  65   1          uDelay(15);
  66   1           CS_OLED = 1;   //ChipUnselected(); 
  67   1      }      
  68          
  69          void WR1BData(unsigned char dat)
  70          {      
  71   1          WRByte(dat, 0);
  72   1      } 
  73          
  74          void WR1BCmd(unsigned char cmd)
  75          {
  76   1          WRByte(cmd, 1);    
  77   1      }  
  78          
  79          
  80          void OledPowerUp(void)
  81          { 
  82   1        int i = 0;
  83   1        int a = 0;
  84   1         for(;i < 30000;i++);  //延时保证可靠显示     
  85   1         WR1BCmd(0xae);   //0xAE 关闭显示    
  86   1         //SetMemoryAddressMode(2);      //0x20(0x02默认),地址自增模式,页模式下PAGE会自动归0,ModeSelect://0, Horizo
             -ntal Addressing Mode ;//1, Vertical Addressing Mode; //2,Page Addressing Mode (default)
  87   1         //SetPageAddressRange(0);
  88   1         //SetColumnAddressRange(0,127);
  89   1         
  90   1         WR1BCmd(0xd5);  WR1BCmd(0x80);   // SetClockDivideRatio(0x80);      //0xD5(0x80) Set Clock as 100 Frames/Se
             -c
  91   1         
  92   1         WR1BCmd(0xa8);  WR1BCmd(0x27);   // SetMultiplexRatio(MAX_ROW-1);   //0xA8(64d=0x3F)参数近似要显示的行数 /
             -/PG9639TLBE(SSD1306)   0xA8(0x27=39D)   
  93   1         WR1BCmd( 0xd3 ); WR1BCmd(0x00);  //SetDisplayVerticalOffset(0);     //0xD3(00)纵向起点行
  94   1         WR1BCmd(0x40);         //SetDisplayStartLine(0);        //0x40(0),行偏移
  95   1        
  96   1         WR1BCmd(0x8d);  WR1BCmd(0x14);     //EnableChargePump(true);   //0x8D(0x14),启用内部电压泵 Enable Embedde
             -d DC/DC Converter 
  97   1         WR1BCmd(0xa1); 
  98   1         WR1BCmd(0xc8); 
  99   1      
 100   1         WR1BCmd(0xda);  WR1BCmd(0x12);   // SetCOMPinsHardwareConfig(0x12);  //0xDA(0x12)//?p31*config(0x32,0x02,
             -0x12,0x22
 101   1         WR1BCmd(0x81);  WR1BCmd(0xaf);   // SetBrightness(m_brightness);    //0x81(0xAF)亮度即Contrast Control,Bri
             -ghtness:0x00(dark)~0xff(light)
 102   1         WR1BCmd(0xd9);  WR1BCmd(0x25);   // SetPreChargePeriod(0x25);       //0xD9(0x25)//?p32*Set Pre-Charge as 15 
             -Clocks & Discharge as 1 Clock
 103   1         WR1BCmd(0xdb);  WR1BCmd(0x20);   //SetVcomhDeselectLevel(0x20);   //0xDB(0x20)//00h  ~ 0.65 x Vcc  //20h  ~
             - 0.77 x Vcc (RESET) //30h  ~ 0.83 x Vcc
 104   1         WR1BCmd(0xa4);         // SwitchEntireDisplayOn(true);  //0xA4 or 0xA5 ,false全亮显示
 105   1         WR1BCmd(0xa6);         // SwitchInverseDisplay(false);  //0xA6 or 0xA7 反相显示
 106   1         WR1BCmd(0xaf);         // SwitchDisplayOn(true);          //0xAF  开启显示  
 107   1      
 108   1        
 109   1        //flush((unsigned char *)HM);//清屏
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/03/2016 08:56:23 PAGE 3   

 110   1        OledClear();
 111   1        
 112   1      }
 113          
 114          void OledPowerDown()
 115          {
 116   1        WR1BCmd(0xae);  // Set Display Off 0xAE
 117   1        WR1BCmd(0x8d);  // Set Charge Pump 0x8D, 0x10
 118   1        WR1BCmd(0x10);
 119   1        Delay100ms(); // Power Stabilized (100ms Delay Recommended)
 120   1        VDDB_OLED = 0;  //Power down VDDB (50ms Delay Recommended)
 121   1        Delay50ms();
 122   1          //Power down VDD
 123   1      
 124   1      }
 125          
 126          void OledEnteringSleepMode()
 127          {
 128   1        WR1BCmd(0xae);  // Set Display Off 0xAE
 129   1        WR1BCmd(0x8d);  // Set Charge Pump 0x8D, 0x10
 130   1        WR1BCmd(0x10);
 131   1        VDDB_OLED = 0;  // Power down VDDB
 132   1      }
 133          
 134          void OledExitingSleepMode()
 135          {
 136   1        VDDB_OLED = 1;  // Power up VDDB (100ms Delay Recommended)
 137   1        WR1BCmd(0x8d);  // Set Charge Pump 0x8D, 0x14
 138   1        WR1BCmd(0x14);
 139   1        WR1BCmd(0xaf);  // Set Display On 0xAF
 140   1      }
 141          
 142          
 143          void SetStartPage(uint8_t page)  //页模式下,设置起始页
 144          {
 145   1        WR1BCmd( 0xB0 | ((page) & 0x0F) );
 146   1      }
 147          
 148          void SetStartColumn(uint8_t ColumnAddress)   //页模式下,设置起始列
 149          {
 150   1           //SH1106,X轴偏移-2,ssd1306 x轴偏移-32
 151   1           ColumnAddress += 32;
 152   1          
 153   1           WR1BCmd(0x0f &  ColumnAddress );          //Set Lower Column (00H - 0FH) 
 154   1           WR1BCmd(0x0f & (ColumnAddress >> 4) | 0x10 );    //Set Higher Column (10H - 1FH)    
 155   1      }
 156          
 157          
 158          /*
 159            功能 : 清屏
 160          */
 161          void OledClear(void)    //此版本为line mode
 162          {
 163   1        unsigned char page = 0;   
 164   1        uint8_t column = 0;
 165   1          for(;page < MAX_PAGE; page++)
 166   1          { 
 167   2            column = 0;
 168   2              SetStartPage(page);   //SetPageAddress(page); 
 169   2              SetStartColumn(0);    //SetColumnAddress(0);
 170   2              for(;column < MAX_COLUMN; column++)
 171   2              {
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/03/2016 08:56:23 PAGE 4   

 172   3                    WR1BData(0x00);
 173   3              }
 174   2          } 
 175   1      }
 176          
 177          /*
 178            功能 : 刷新整个界面
 179            输入 : 整个界面的位值
 180          */
 181          void OledFlush(unsigned char *buf)
 182          {
 183   1        unsigned char page = 0;   
 184   1        uint8_t column = 0;
 185   1        unsigned int n = 0;
 186   1          for(;page < MAX_PAGE; page++)
 187   1          { 
 188   2            column = 0;
 189   2              SetStartPage(page);   //SetPageAddress(page); 
 190   2              SetStartColumn(0);    //SetColumnAddress(0);
 191   2              for(;column < MAX_COLUMN; column++)
 192   2              {
 193   3                  WR1BData(buf[n++]);
 194   3              }
 195   2          } 
 196   1      }
 197          
 198          
 199          
 200          /*
 201            功能 : 输出ASSIC码的数据，最多输出24个字符，只能输出字母和数字，特殊字符都显示为空格
 202            输入 : 字符串
 203          */
 204          void OledWriteMessage(char *str)
 205          {
 206   1        unsigned char charNum = 0;
 207   1        unsigned char i = 0;
 208   1        while(*str){
 209   2      
 210   2          if(charNum < 12){     //第一排字
 211   3            SetStartPage(1);          //SetPageAddress(page); 
 212   3                SetStartColumn(charNum * 8);    //SetColumnAddress(0);
 213   3      
 214   3              }
 215   2              else if(charNum < 24){
 216   3            SetStartPage(3);          //SetPageAddress(page); 
 217   3            SetStartColumn((charNum - 12) * 8);   //SetColumnAddress(0);
 218   3      
 219   3          }
 220   2          else
 221   2            return;
 222   2        
 223   2            if(*str >= '0' && *str <= '9'){   // 如果是数字
 224   3            for(i = 0; i < 8; i++){
 225   4              WR1BData(Num[*str - '0'][i]);
 226   4            }
 227   3            }
 228   2          else if(*str >= 'a' && *str <= 'z'){  // a - z
 229   3            for(i = 0; i < 8; i++){
 230   4              WR1BData(LETTER[*str - 'a'][i]);
 231   4            }
 232   3          }
 233   2          else if(*str >= 'A' && *str <= 'Z'){  // A - Z
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/03/2016 08:56:23 PAGE 5   

 234   3            for(i = 0; i < 8; i++){
 235   4              WR1BData(LETTER[*str - 'A' + 26][i]);
 236   4            }
 237   3          }
 238   2          else{             // 其余都为空格
 239   3            for(i = 0; i < 8; i++){
 240   4              WR1BData(0x00);
 241   4            }
 242   3          }
 243   2          if(charNum < 12){
 244   3            SetStartPage(2);          //SetPageAddress(page); 
 245   3                SetStartColumn(charNum * 8);    //SetColumnAddress(0);
 246   3          }
 247   2          else if(charNum < 24){
 248   3            SetStartPage(4);          //SetPageAddress(page); 
 249   3            SetStartColumn((charNum - 12) * 8);   //SetColumnAddress(0);
 250   3      
 251   3          }
 252   2          else return;
 253   2          
 254   2            if(*str >= '0' && *str <= '9'){   // 如果是数字
 255   3            for(i = 0; i < 8; i++){
 256   4              WR1BData(Num[*str - '0'][i + 8]);
 257   4            }
 258   3            }
 259   2          else if(*str >= 'a' && *str <= 'z'){  // a - z
 260   3            for(i = 0; i < 8; i++){
 261   4              WR1BData(LETTER[*str - 'a'][i + 8]);
 262   4            }
 263   3          }
 264   2          else if(*str >= 'A' && *str <= 'Z'){  // A - Z
 265   3            for(i = 0; i < 8; i++){
 266   4              WR1BData(LETTER[*str - 'A' + 26][i + 8]);
 267   4            }
 268   3          }
 269   2          else{             // 其余都为空格
 270   3            for(i = 0; i < 8; i++){
 271   4              WR1BData(0x00);
 272   4            }
 273   3          }
 274   2          charNum++;
 275   2          str++;
 276   2        }
 277   1      }
 278          
 279          /*
 280            功能 : 输出一个字符的HEX码
 281            输入 : Page 和 Col 显示的位置
 282              Page : 1 或 3 ; 总共5行，从0开始， 第一行只有7位，一个字符需要2个page，所以为1和3page开始
 283              Col : 最好8的倍数 因为每个字符需要两位16列
 284          */
 285          void OledWriteWordByHex(unsigned char Page, unsigned char Col, unsigned char Data)
 286          {
 287   1        unsigned char i = 0;
 288   1        unsigned char left = (Data >> 4);
 289   1        unsigned char right = (Data & 0x0f);
 290   1        SetStartPage(Page);         //SetPageAddress(page); 
 291   1          SetStartColumn(Col);
 292   1        for(i = 0; i < 8; i++){
 293   2          WR1BData(Num[left][i]);
 294   2        }
 295   1        SetStartPage(Page + 1);         //SetPageAddress(page); 
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/03/2016 08:56:23 PAGE 6   

 296   1          SetStartColumn(Col);
 297   1        for(i = 0; i < 8; i++){
 298   2            WR1BData(Num[left][i + 8]);
 299   2        }
 300   1      
 301   1        SetStartPage(Page);         //SetPageAddress(page); 
 302   1          SetStartColumn(Col + 8);
 303   1        for(i = 0; i < 8; i++){
 304   2          if(i != 7)
 305   2            WR1BData(Num[right][i]);
 306   2          else
 307   2            WR1BData(Num[right][i] | 1);
 308   2        }
 309   1        SetStartPage(Page + 1);         //SetPageAddress(page); 
 310   1          SetStartColumn(Col + 8);
 311   1        for(i = 0; i < 8; i++){
 312   2            WR1BData(Num[right][i + 8]);
 313   2        }
 314   1      }
 315          
 316          
 317          /*
 318            功能 : 输出HEX码的数据，最多输出24个数字，即12个字符
 319            输入 : 数组数据
 320          */
 321          void OledWriteMessageByHex(unsigned char *Data)
 322          {
 323   1        unsigned char dataNum = 0;
 324   1        while(Data[dataNum] != 0){
 325   2          if(dataNum < 6){
 326   3            OledWriteWordByHex(1, dataNum * 16, Data[dataNum]);
 327   3          }
 328   2          else if(dataNum < 12)
 329   2            OledWriteWordByHex(3, (dataNum - 6) * 16, Data[dataNum]);
 330   2          else 
 331   2            return;
 332   2          ++dataNum;
 333   2        }
 334   1        
 335   1      }
 336          
 337          /*
 338            功能 : 使用5*7字模  输出一个字符的HEX码
 339            输入 : Page 和 Col 显示的位置
 340              Page : 
 341              Col : 最好6的倍数 
 342          */
 343          
 344          void OledWriteWordByHex57(unsigned char Page, unsigned char Col, unsigned char Data)
 345          {
 346   1        unsigned char i = 0;
 347   1        unsigned char left = (Data >> 4);
 348   1        unsigned char right = (Data & 0x0f);
 349   1        SetStartPage(Page);         //SetPageAddress(page); 
 350   1          SetStartColumn(Col);
 351   1        if(left >=0 && left <= 9){
 352   2          for(i = 0; i < 5; i++){
 353   3            WR1BData(Fonts[('0' - 32 + left) * 5 + i]);
 354   3          }
 355   2        }
 356   1        else if(left >= 10 && left <= 15){
 357   2          for(i = 0; i < 5; i++){
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/03/2016 08:56:23 PAGE 7   

 358   3            WR1BData(Fonts[('A' - 32 + left - 10) * 5 + i]);
 359   3          }
 360   2        }
 361   1        else return;
 362   1          
 363   1        WR1BData(0x00);
 364   1        
 365   1      //  SetStartPage(Page);         //SetPageAddress(page); 
 366   1      //  SetStartColumn(Col + 6);
 367   1        
 368   1        if(right >=0 && right <= 9){
 369   2          for(i = 0; i < 5; i++){
 370   3            WR1BData(Fonts[('0' - 32 + right) * 5 + i]);
 371   3          }
 372   2        }
 373   1        else if(right >= 10 && right <= 15){
 374   2          for(i = 0; i < 5; i++){
 375   3            WR1BData(Fonts[('A' - 32 + right - 10) * 5 + i]);
 376   3          }
 377   2        }
 378   1        else return;
 379   1        WR1BData(0x03); 
 380   1      }
 381          
 382          
 383          /*
 384            功能 : 使用5*7字模  输出HEX码的数据，最多输出64个数字，即32个字符
 385            输入 : 数组数据
 386          */
 387          void OledWriteMessageByHex57(unsigned char *str)
 388          {
 389   1        unsigned char charNum = 0;
 390   1        unsigned char i = 0;
 391   1        clearPageCol(0, 0);
 392   1        while(*str){
 393   2          if(charNum < 8){      //第一排字
 394   3            OledWriteWordByHex57(1, charNum * 12, *str);
 395   3              }
 396   2              else if(charNum < 16){
 397   3            OledWriteWordByHex57(2, (charNum - 8) * 12, *str);
 398   3      
 399   3          }
 400   2          else if(charNum < 24){
 401   3            OledWriteWordByHex57(3, (charNum - 16) * 12, *str);
 402   3      
 403   3          }
 404   2          else if(charNum < 32){
 405   3            OledWriteWordByHex57(4, (charNum - 24) * 12, *str);
 406   3      
 407   3          }
 408   2          else
 409   2            return;
 410   2          str++;
 411   2          charNum++;
 412   2        }
 413   1        
 414   1        while(1){
 415   2            
 416   2            if(charNum < 8){      //第一排字
 417   3              OledWriteAssic57(1, charNum * 6, ' ');
 418   3              OledWriteAssic57(1, (charNum + 1) * 6, ' ');
 419   3            }
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/03/2016 08:56:23 PAGE 8   

 420   2            else if(charNum < 16){
 421   3              OledWriteAssic57(2, (charNum - 16) * 6, ' ');
 422   3              OledWriteAssic57(2, (charNum - 16 + 1) * 6, ' ');
 423   3        
 424   3            }
 425   2            else if(charNum < 24){
 426   3              OledWriteAssic57(3, (charNum - 32) * 6, ' ');
 427   3              OledWriteAssic57(3, (charNum - 32 + 1) * 6, ' ');
 428   3        
 429   3            }
 430   2            else if(charNum < 32){
 431   3              OledWriteAssic57(4, (charNum - 48) * 6, ' ');
 432   3              OledWriteAssic57(4,(charNum - 48 + 1) * 6, ' ');
 433   3        
 434   3            }
 435   2            else
 436   2              break;
 437   2            charNum++;
 438   2            }
 439   1      }
 440          
 441          /*
 442            功能 : 使用5*7字模 输出一个字符的assic码
 443            输入 : Page 和 Col 显示的位置
 444              Page : 
 445              Col : 最好6的倍数 
 446              Data : 字母
 447          */
 448          void OledWriteAssic57(unsigned char Page, unsigned char Col,unsigned char Data)
 449          {
 450   1          unsigned char i = 0;
 451   1          SetStartPage(Page);         //SetPageAddress(page); 
 452   1            SetStartColumn(Col);
 453   1          for(i = 0; i < 5; i++){
 454   2            WR1BData(Fonts[(Data - 32) * 5 + i]);
 455   2          }
 456   1          WR1BData(0x00); 
 457   1      }
 458          
 459          /*
 460            功能 : 使用5*7字模 输出ASSIC码的数据，最多输出64个字符
 461            输入 : 字符串
 462          */
 463          void OledWriteMessage57(char *str)
 464          {
 465   1        unsigned char charNum = 0;
 466   1        unsigned char i = 0;
 467   1        unsigned char page = 0;
 468   1        clearPageCol(0, 0);
 469   1        
 470   1        while(*str){
 471   2      
 472   2          if(charNum < 16){     //第一排字
 473   3            OledWriteAssic57(1, charNum * 6, *str);
 474   3              }
 475   2              else if(charNum < 32){
 476   3            OledWriteAssic57(2, (charNum - 16) * 6, *str);
 477   3      
 478   3          }
 479   2          else if(charNum < 48){
 480   3            OledWriteAssic57(3, (charNum - 32) * 6, *str);
 481   3      
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/03/2016 08:56:23 PAGE 9   

 482   3          }
 483   2          else if(charNum < 64){
 484   3            OledWriteAssic57(4, (charNum - 48) * 6, *str);
 485   3      
 486   3          }
 487   2          else
 488   2            break;
 489   2          str++;
 490   2          charNum++;
 491   2        }
 492   1        
 493   1        while(1){
 494   2      
 495   2          if(charNum < 16){     //第一排字
 496   3            OledWriteAssic57(1, charNum * 6, ' ');
 497   3              }
 498   2              else if(charNum < 32){
 499   3            OledWriteAssic57(2, (charNum - 16) * 6, ' ');
 500   3      
 501   3          }
 502   2          else if(charNum < 48){
 503   3            OledWriteAssic57(3, (charNum - 32) * 6, ' ');
 504   3      
 505   3          }
 506   2          else if(charNum < 64){
 507   3            OledWriteAssic57(4, (charNum - 48) * 6, ' ');
 508   3      
 509   3          }
 510   2          else
 511   2            break;
 512   2          charNum++;
 513   2          }
 514   1      }
 515          
 516          /*
 517            功能 : 清除某行某列开始的值
 518            输入 : Page 和 Col 的位置
 519          */
 520          void clearPageCol(unsigned char Page, unsigned char Col)
 521          {
 522   1        unsigned char i = Col;
 523   1        SetStartPage(Page);         //SetPageAddress(page); 
 524   1          SetStartColumn(Col);
 525   1        for(; i < MAX_COLUMN; i++){
 526   2          WR1BData(0);
 527   2        }
 528   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2573    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      36
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
