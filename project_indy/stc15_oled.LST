C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/08/2016 09:44:05 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE STC15_OLED
OBJECT MODULE PLACED IN stc15_oled.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE stc15_oled.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "stc15_oled.h"
   2          
   3          void InitOled()
   4          {
   5   1        //  6.1  CS#  片选  配置 强输出。
   6   1        //  6.2  D/C#  数据或命令 选择    配置 强输出。
   7   1        //  6.3  E/RD#  读写使能 或读   配置 强输出。
   8   1        //  6.4  R/W# 读写选择 或 写    配置 强输出。
   9   1        P2M1 = 0x00;
  10   1        P2M0 = 0xff;  
  11   1        
  12   1        BS1_OLED = 0; 
  13   1        BS2_OLED = 0; //BS1 BS2  配置 强输出 ；都拉高 ；选择 80xx 总线。  00 选择spi
  14   1        
  15   1        //6.5  D0~D7  数据总线   写  配置 强输出；读配置 输入带上拉电阻。
  16   1        //P7M1 &= ~0x80;  // D0 P7.7
  17   1        //P7M0 |= 0x80;
  18   1        //P4M1 &= ~0x30;  // D1 P4.5
  19   1        //P4M0 |= 0x30; // D2 P4.6
  20   1        //P0M1 &= ~0x1F;// D3 P0.0
  21   1        //P0M0 |= 0x1F;// D4 P0.1
  22   1        // D5 P0.2
  23   1        // D6 P0.3
  24   1        // D7 P0.4
  25   1      
  26   1        //P2M1 &= ~0x80;  // SDIN P2.7
  27   1        //P2M0 |= 0x80;
  28   1      
  29   1        P7M1 &= ~0x10;  // SCLK P7.4
  30   1        P7M0 |= 0x10;
  31   1      
  32   1      }
  33          
  34          // ------------------------------模拟 SPI ----------------------------------------------
  35          void uDelay(unsigned char t)
  36          {   
  37   1           while(t--);
  38   1      }
  39          
  40          
  41          void WRByte(unsigned char dat,unsigned char bIsCmd) //写完一字节,column会自增
  42          {
  43   1          unsigned char i=0x80; 
  44   1           CS_OLED = 0;   // ChipSelected(); 
  45   1           if(bIsCmd == 1) 
  46   1           {
  47   2            DC_OLED = 0;  // CmdInput();
  48   2           }else   
  49   1           {
  50   2            DC_OLED = 1;  // DataInput();
  51   2           }
  52   1           for(;i>0;i>>=1) //OLED从字节的高位D7输入,至到D0 -- SPI模拟
  53   1           {
  54   2             SCLK_OLED = 0; // SCLK.low();  
  55   2             SDIN_OLED = i & dat; // SDIN.set(i&dat);      
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/08/2016 09:44:05 PAGE 2   

  56   2             uDelay(15);
  57   2             SCLK_OLED = 1; // SCLK.high();      
  58   2             uDelay(15);          
  59   2           }
  60   1           SCLK_OLED = 0;
  61   1           SDIN_OLED = 1;
  62   1           uDelay(15);
  63   1          SCLK_OLED = 1; // SCLK.high(); 
  64   1          
  65   1          uDelay(15);
  66   1           CS_OLED = 1;   //ChipUnselected(); 
  67   1      }      
  68          
  69          void WR1BData(unsigned char dat)
  70          {      
  71   1          WRByte(dat, 0);
  72   1      } 
  73          
  74          void WR1BCmd(unsigned char cmd)
  75          {
  76   1          WRByte(cmd, 1);    
  77   1      }  
  78          
  79          
  80          void OledPowerUp(void)
  81          { 
  82   1        int i = 0;
  83   1        int a = 0;
  84   1         for(;i < 30000;i++);  //延时保证可靠显示     
  85   1         WR1BCmd(0xae);   //0xAE 关闭显示    
  86   1         //SetMemoryAddressMode(2);      //0x20(0x02默认),地址自增模式,页模式下PAGE会自动归0,ModeSelect://0, Horizo
             -ntal Addressing Mode ;//1, Vertical Addressing Mode; //2,Page Addressing Mode (default)
  87   1         //SetPageAddressRange(0);
  88   1         //SetColumnAddressRange(0,127);
  89   1         
  90   1         WR1BCmd(0xd5);  WR1BCmd(0x80);   // SetClockDivideRatio(0x80);      //0xD5(0x80) Set Clock as 100 Frames/Se
             -c
  91   1         
  92   1         WR1BCmd(0xa8);  WR1BCmd(0x27);   // SetMultiplexRatio(MAX_ROW-1);   //0xA8(64d=0x3F)参数近似要显示的行数 /
             -/PG9639TLBE(SSD1306)   0xA8(0x27=39D)   
  93   1         WR1BCmd( 0xd3 ); WR1BCmd(0x00);  //SetDisplayVerticalOffset(0);     //0xD3(00)纵向起点行
  94   1         WR1BCmd(0x40);         //SetDisplayStartLine(0);        //0x40(0),行偏移
  95   1        
  96   1         WR1BCmd(0x8d);  WR1BCmd(0x14);     //EnableChargePump(true);   //0x8D(0x14),启用内部电压泵 Enable Embedde
             -d DC/DC Converter 
  97   1         WR1BCmd(0xa1); 
  98   1         WR1BCmd(0xc8); 
  99   1      
 100   1         WR1BCmd(0xda);  WR1BCmd(0x12);   // SetCOMPinsHardwareConfig(0x12);  //0xDA(0x12)//?p31*config(0x32,0x02,
             -0x12,0x22
 101   1         WR1BCmd(0x81);  WR1BCmd(0xaf);   // SetBrightness(m_brightness);    //0x81(0xAF)亮度即Contrast Control,Bri
             -ghtness:0x00(dark)~0xff(light)
 102   1         WR1BCmd(0xd9);  WR1BCmd(0x25);   // SetPreChargePeriod(0x25);       //0xD9(0x25)//?p32*Set Pre-Charge as 15 
             -Clocks & Discharge as 1 Clock
 103   1         WR1BCmd(0xdb);  WR1BCmd(0x20);   //SetVcomhDeselectLevel(0x20);   //0xDB(0x20)//00h  ~ 0.65 x Vcc  //20h  ~
             - 0.77 x Vcc (RESET) //30h  ~ 0.83 x Vcc
 104   1         WR1BCmd(0xa4);         // SwitchEntireDisplayOn(true);  //0xA4 or 0xA5 ,false全亮显示
 105   1         WR1BCmd(0xa6);         // SwitchInverseDisplay(false);  //0xA6 or 0xA7 反相显示
 106   1         WR1BCmd(0xaf);         // SwitchDisplayOn(true);          //0xAF  开启显示  
 107   1      
 108   1        
 109   1        //flush((unsigned char *)HM);//清屏
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/08/2016 09:44:05 PAGE 3   

 110   1        OledClear();
 111   1        
 112   1      }
 113          
 114          void OledPowerDown()
 115          {
 116   1        WR1BCmd(0xae);  // Set Display Off 0xAE
 117   1        WR1BCmd(0x8d);  // Set Charge Pump 0x8D, 0x10
 118   1        WR1BCmd(0x10);
 119   1        Delay100ms(); // Power Stabilized (100ms Delay Recommended)
 120   1        VDDB_OLED = 0;  //Power down VDDB (50ms Delay Recommended)
 121   1        Delay50ms();
 122   1          //Power down VDD
 123   1      
 124   1      }
 125          
 126          void OledEnteringSleepMode()
 127          {
 128   1        WR1BCmd(0xae);  // Set Display Off 0xAE
 129   1        WR1BCmd(0x8d);  // Set Charge Pump 0x8D, 0x10
 130   1        WR1BCmd(0x10);
 131   1        VDDB_OLED = 0;  // Power down VDDB
 132   1      }
 133          
 134          void OledExitingSleepMode()
 135          {
 136   1        VDDB_OLED = 1;  // Power up VDDB (100ms Delay Recommended)
 137   1        WR1BCmd(0x8d);  // Set Charge Pump 0x8D, 0x14
 138   1        WR1BCmd(0x14);
 139   1        WR1BCmd(0xaf);  // Set Display On 0xAF
 140   1      }
 141          
 142          
 143          char SetStartPage(uint8_t page)  //页模式下,设置起始页
 144          {
 145   1        if(page > 4){
 146   2          WR1BCmd( 0xB0 | (4 & 0x0F) );
 147   2          return 1;
 148   2        }
 149   1        WR1BCmd( 0xB0 | ((page) & 0x0F) );
 150   1        return 0;
 151   1      }
 152          
 153          char SetStartColumn(uint8_t ColumnAddress)   //页模式下,设置起始列
 154          {
 155   1        if(ColumnAddress > MAX_COLUMN){
 156   2          return 1;
 157   2        }
 158   1        //SH1106,X轴偏移-2,ssd1306 x轴偏移-32
 159   1        ColumnAddress += 32;
 160   1      
 161   1        WR1BCmd(0x0f &  ColumnAddress );         //Set Lower Column (00H - 0FH) 
 162   1        WR1BCmd(0x0f & (ColumnAddress >> 4) | 0x10 );     //Set Higher Column (10H - 1FH)
 163   1          return 0;
 164   1      }
 165          
 166          
 167          /*
 168            功能 : 清屏
 169          */
 170          void OledClear(void)    //此版本为line mode
 171          {
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/08/2016 09:44:05 PAGE 4   

 172   1        unsigned char page = 0;   
 173   1        uint8_t column = 0;
 174   1          for(;page < MAX_PAGE; page++)
 175   1          { 
 176   2            column = 0;
 177   2              SetStartPage(page);   //SetPageAddress(page); 
 178   2              SetStartColumn(0);    //SetColumnAddress(0);
 179   2              for(;column < MAX_COLUMN; column++)
 180   2              {
 181   3                    WR1BData(0x00);
 182   3              }
 183   2          } 
 184   1      }
 185          
 186          /*
 187            功能 : 刷新整个界面
 188            输入 : 整个界面的位值
 189          */
 190          char OledFlush(unsigned char *buf)
 191          {
 192   1        unsigned char page = 0;   
 193   1        uint8_t column = 0;
 194   1        unsigned int n = 0;
 195   1      
 196   1        if(buf == 0)
 197   1          return 1;
 198   1          for(;page < MAX_PAGE; page++)
 199   1          { 
 200   2            column = 0;
 201   2              SetStartPage(page);   //SetPageAddress(page); 
 202   2              SetStartColumn(0);    //SetColumnAddress(0);
 203   2              for(;column < MAX_COLUMN; column++)
 204   2              {
 205   3                  WR1BData(buf[n++]);
 206   3              }
 207   2          }
 208   1        return 0; 
 209   1      }
 210          
 211          
 212          /*
 213            功能 : 刷新某一行
 214            输入 : 某一行开始位置，和数据
 215          */
 216          char OledFlushPage(unsigned char Page, unsigned char Col,unsigned char *buf, unsigned char bufNum)
 217          {  
 218   1        uint8_t column = 0;
 219   1        
 220   1        if(Page > 4 || Col > MAX_COLUMN || buf == NULL || Page < 0 || Col < 0 || Col + bufNum > MAX_COLUMN)
 221   1          return 1;
 222   1        
 223   1          SetStartPage(Page);   //SetPageAddress(page); 
 224   1          SetStartColumn(Col);    //SetColumnAddress(0);
 225   1          
 226   1          for(;column < bufNum && Col + column < MAX_COLUMN; column++)
 227   1          {
 228   2              WR1BData(buf[column]);
 229   2          } 
 230   1      
 231   1        return 0;
 232   1      }
 233          
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/08/2016 09:44:05 PAGE 5   

 234          
 235          /*
 236            功能 : 输出ASSIC码的数据，最多输出24个字符，只能输出字母和数字，特殊字符都显示为空格
 237            输入 : 字符串
 238          */
 239          void OledWriteMessage(char *str)
 240          {
 241   1        unsigned char charNum = 0;
 242   1        unsigned char i = 0;
 243   1        
 244   1        while(*str){
 245   2      
 246   2          if(charNum < 12){     //第一排字
 247   3            SetStartPage(1);          //SetPageAddress(page); 
 248   3                SetStartColumn(charNum * 8);    //SetColumnAddress(0);
 249   3      
 250   3              }
 251   2              else if(charNum < 24){
 252   3            SetStartPage(3);          //SetPageAddress(page); 
 253   3            SetStartColumn((charNum - 12) * 8);   //SetColumnAddress(0);
 254   3      
 255   3          }
 256   2          else
 257   2            return;
 258   2        
 259   2            if(*str >= '0' && *str <= '9'){   // 如果是数字
 260   3            for(i = 0; i < 8; i++){
 261   4              WR1BData(Num[*str - '0'][i]);
 262   4            }
 263   3            }
 264   2          else if(*str >= 'a' && *str <= 'z'){  // a - z
 265   3            for(i = 0; i < 8; i++){
 266   4              WR1BData(LETTER[*str - 'a'][i]);
 267   4            }
 268   3          }
 269   2          else if(*str >= 'A' && *str <= 'Z'){  // A - Z
 270   3            for(i = 0; i < 8; i++){
 271   4              WR1BData(LETTER[*str - 'A' + 26][i]);
 272   4            }
 273   3          }
 274   2          else{             // 其余都为空格
 275   3            for(i = 0; i < 8; i++){
 276   4              WR1BData(0x00);
 277   4            }
 278   3          }
 279   2          if(charNum < 12){
 280   3            SetStartPage(2);          //SetPageAddress(page); 
 281   3                SetStartColumn(charNum * 8);    //SetColumnAddress(0);
 282   3          }
 283   2          else if(charNum < 24){
 284   3            SetStartPage(4);          //SetPageAddress(page); 
 285   3            SetStartColumn((charNum - 12) * 8);   //SetColumnAddress(0);
 286   3      
 287   3          }
 288   2          else return;
 289   2          
 290   2            if(*str >= '0' && *str <= '9'){   // 如果是数字
 291   3            for(i = 0; i < 8; i++){
 292   4              WR1BData(Num[*str - '0'][i + 8]);
 293   4            }
 294   3            }
 295   2          else if(*str >= 'a' && *str <= 'z'){  // a - z
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/08/2016 09:44:05 PAGE 6   

 296   3            for(i = 0; i < 8; i++){
 297   4              WR1BData(LETTER[*str - 'a'][i + 8]);
 298   4            }
 299   3          }
 300   2          else if(*str >= 'A' && *str <= 'Z'){  // A - Z
 301   3            for(i = 0; i < 8; i++){
 302   4              WR1BData(LETTER[*str - 'A' + 26][i + 8]);
 303   4            }
 304   3          }
 305   2          else{             // 其余都为空格
 306   3            for(i = 0; i < 8; i++){
 307   4              WR1BData(0x00);
 308   4            }
 309   3          }
 310   2          charNum++;
 311   2          str++;
 312   2        }
 313   1      }
 314          
 315          /*
 316            功能 : 输出一个字符的HEX码
 317            输入 : Page 和 Col 显示的位置
 318              Page : 1 或 3 ; 总共5行，从0开始， 第一行只有7位，一个字符需要2个page，所以为1和3page开始
 319              Col : 最好8的倍数 因为每个字符需要两位16列
 320          */
 321          char OledWriteWordByHex(unsigned char Page, unsigned char Col, unsigned char Data)
 322          {
 323   1        unsigned char i = 0;
 324   1        unsigned char left = (Data >> 4);
 325   1        unsigned char right = (Data & 0x0f);
 326   1        if(Page > 4 || Col > MAX_COLUMN)
 327   1          return 1;
 328   1        SetStartPage(Page);         //SetPageAddress(page); 
 329   1          SetStartColumn(Col);
 330   1        for(i = 0; i < 8; i++){
 331   2          WR1BData(Num[left][i]);
 332   2        }
 333   1        SetStartPage(Page + 1);         //SetPageAddress(page); 
 334   1          SetStartColumn(Col);
 335   1        for(i = 0; i < 8; i++){
 336   2            WR1BData(Num[left][i + 8]);
 337   2        }
 338   1      
 339   1        SetStartPage(Page);         //SetPageAddress(page); 
 340   1          SetStartColumn(Col + 8);
 341   1        for(i = 0; i < 8; i++){
 342   2          if(i != 7)
 343   2            WR1BData(Num[right][i]);
 344   2          else
 345   2            WR1BData(Num[right][i] | 1);
 346   2        }
 347   1        SetStartPage(Page + 1);         //SetPageAddress(page); 
 348   1          SetStartColumn(Col + 8);
 349   1        for(i = 0; i < 8; i++){
 350   2            WR1BData(Num[right][i + 8]);
 351   2        }
 352   1        return 0;
 353   1      }
 354          
 355          
 356          /*
 357            功能 : 输出HEX码的数据，最多输出24个数字，即12个字符
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/08/2016 09:44:05 PAGE 7   

 358            输入 : 数组数据，以及数组的长度
 359            输出 : 当数组超过12个字符时，显示12个字符，并返回错误代码
 360          */
 361          char OledWriteBufByHex(unsigned char *Data, unsigned char Num)
 362          {
 363   1        unsigned char dataNum = 0;
 364   1        if(Data == NULL)
 365   1          return 1;
 366   1        while(dataNum < Num){
 367   2          if(dataNum < 6){
 368   3            OledWriteWordByHex(1, dataNum * 16, Data[dataNum]);
 369   3          }
 370   2          else if(dataNum < 12)
 371   2            OledWriteWordByHex(3, (dataNum - 6) * 16, Data[dataNum]);
 372   2          else 
 373   2            return 1;
 374   2          ++dataNum;
 375   2        }
 376   1        return 0;
 377   1        
 378   1      }
 379          
 380          /*
 381            功能 : 使用5*7字模  输出一个字符的HEX码
 382            输入 : Page 和 Col 显示的位置
 383              Page : 
 384              Col : 最好6的倍数 
 385          */
 386          
 387          char OledWriteWordByHex57(unsigned char Page, unsigned char Col, unsigned char Data)
 388          {
 389   1        unsigned char i = 0;
 390   1        unsigned char left = (Data >> 4);
 391   1        unsigned char right = (Data & 0x0f);
 392   1      
 393   1        if(Page > 4 || Col > MAX_COLUMN)
 394   1          return 1;
 395   1        
 396   1        SetStartPage(Page);         //SetPageAddress(page); 
 397   1          SetStartColumn(Col);
 398   1        if(left >=0 && left <= 9){
 399   2          for(i = 0; i < 5; i++){
 400   3            WR1BData(Fonts[('0' - 32 + left) * 5 + i]);
 401   3          }
 402   2        }
 403   1        else if(left >= 10 && left <= 15){
 404   2          for(i = 0; i < 5; i++){
 405   3            WR1BData(Fonts[('A' - 32 + left - 10) * 5 + i]);
 406   3          }
 407   2        }
 408   1        else return 0;
 409   1          
 410   1        WR1BData(0x00);
 411   1        
 412   1      //  SetStartPage(Page);         //SetPageAddress(page); 
 413   1      //  SetStartColumn(Col + 6);
 414   1        
 415   1        if(right >=0 && right <= 9){
 416   2          for(i = 0; i < 5; i++){
 417   3            WR1BData(Fonts[('0' - 32 + right) * 5 + i]);
 418   3          }
 419   2        }
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/08/2016 09:44:05 PAGE 8   

 420   1        else if(right >= 10 && right <= 15){
 421   2          for(i = 0; i < 5; i++){
 422   3            WR1BData(Fonts[('A' - 32 + right - 10) * 5 + i]);
 423   3          }
 424   2        }
 425   1        else return 0;
 426   1        WR1BData(0x03); 
 427   1        return 0;
 428   1      }
 429          
 430          
 431          /*
 432            功能 : 使用5*7字模  输出HEX码的数据，最多输出64个数字，即32个字符
 433            输入 : 数组数据
 434          */
 435          char OledWriteBufByHex57(unsigned char *str, unsigned char Num)
 436          {
 437   1        unsigned char charNum = 0;
 438   1        unsigned char i = 0;
 439   1        //clearPageCol(0, 0);
 440   1      
 441   1        if(str == NULL) return 1;
 442   1        
 443   1        while(charNum < Num){
 444   2          if(charNum < 8){      //第一排字
 445   3            OledWriteWordByHex57(1, charNum * 12, *str);
 446   3              }
 447   2              else if(charNum < 16){
 448   3            OledWriteWordByHex57(2, (charNum - 8) * 12, *str);
 449   3      
 450   3          }
 451   2          else if(charNum < 24){
 452   3            OledWriteWordByHex57(3, (charNum - 16) * 12, *str);
 453   3      
 454   3          }
 455   2          else if(charNum < 32){
 456   3            OledWriteWordByHex57(4, (charNum - 24) * 12, *str);
 457   3      
 458   3          }
 459   2          else
 460   2            return 1;
 461   2          str++;
 462   2          charNum++;
 463   2        }
 464   1      
 465   1        return 0;
 466   1        /*
 467   1        while(1){
 468   1            
 469   1            if(charNum < 8){      //第一排字
 470   1              OledWriteAssic57(1, charNum * 6, ' ');
 471   1              OledWriteAssic57(1, (charNum + 1) * 6, ' ');
 472   1            }
 473   1            else if(charNum < 16){
 474   1              OledWriteAssic57(2, (charNum - 16) * 6, ' ');
 475   1              OledWriteAssic57(2, (charNum - 16 + 1) * 6, ' ');
 476   1        
 477   1            }
 478   1            else if(charNum < 24){
 479   1              OledWriteAssic57(3, (charNum - 32) * 6, ' ');
 480   1              OledWriteAssic57(3, (charNum - 32 + 1) * 6, ' ');
 481   1        
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/08/2016 09:44:05 PAGE 9   

 482   1            }
 483   1            else if(charNum < 32){
 484   1              OledWriteAssic57(4, (charNum - 48) * 6, ' ');
 485   1              OledWriteAssic57(4,(charNum - 48 + 1) * 6, ' ');
 486   1        
 487   1            }
 488   1            else
 489   1              break;
 490   1            charNum++;
 491   1            }
 492   1        */
 493   1      }
 494          
 495          /*
 496            功能 : 使用5*7字模 输出一个字符的assic码
 497            输入 : Page 和 Col 显示的位置
 498              Page : 
 499              Col : 最好6的倍数 
 500              Data : 字母
 501          */
 502          char OledWriteAssic57(unsigned char Page, unsigned char Col,unsigned char Data)
 503          {
 504   1          unsigned char i = 0;
 505   1          
 506   1          if(Page > 4 || Col > MAX_COLUMN)
 507   1            return 1;
 508   1      
 509   1          if(Data < 32){
 510   2            Data = 127;
 511   2            SetStartPage(Page);         //SetPageAddress(page); 
 512   2              SetStartColumn(Col);
 513   2            for(i = 0; i < 5; i++){
 514   3              WR1BData(Fonts[(Data - 32) * 5 + i]);
 515   3            }
 516   2            WR1BData(0x00); 
 517   2            return 1;
 518   2          }
 519   1          
 520   1          SetStartPage(Page);         //SetPageAddress(page); 
 521   1            SetStartColumn(Col);
 522   1          for(i = 0; i < 5; i++){
 523   2            WR1BData(Fonts[(Data - 32) * 5 + i]);
 524   2          }
 525   1          WR1BData(0x00); 
 526   1      
 527   1          return 0;
 528   1      }
 529          
 530          /*
 531            功能 : 用于state 使用5*7字模 输出一个字符的assic码  
 532            输入 : Page 和 Col 显示的位置
 533              Page : 
 534              Col : 最好6的倍数 
 535              Data : 字母
 536          */
 537          char OledAssicForState(unsigned char Page, unsigned char Col,unsigned char Data)
 538          {
 539   1          unsigned char i = 0;
 540   1          
 541   1          if(Page > 4 || Col > MAX_COLUMN)
 542   1            return 1;
 543   1          if(Data < 32){
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/08/2016 09:44:05 PAGE 10  

 544   2            Data = 127;
 545   2            SetStartPage(Page);         //SetPageAddress(page); 
 546   2              SetStartColumn(Col);
 547   2            for(i = 0; i < 5; i++){
 548   3              WR1BData(Fonts[(Data - 32) * 5 + i] << 1);
 549   3            }
 550   2            WR1BData(0x00); 
 551   2            return 1;
 552   2          }
 553   1          
 554   1          SetStartPage(Page);         //SetPageAddress(page); 
 555   1            SetStartColumn(Col);
 556   1          for(i = 0; i < 5; i++){
 557   2            WR1BData(Fonts[(Data - 32) * 5 + i] << 1);
 558   2          }
 559   1          WR1BData(0x00);
 560   1      
 561   1          return 0;
 562   1      }
 563          
 564          
 565          
 566          /*
 567            功能 : 使用5*7字模 输出ASSIC码的数据，最多输出64个字符
 568            输入 : 字符串
 569          */
 570          void OledWriteMessage57(char *str)
 571          {
 572   1        unsigned char charNum = 0;
 573   1        unsigned char i = 0;
 574   1        unsigned char page = 0;
 575   1        
 576   1        while(*str){
 577   2      
 578   2          if(charNum < 16){     //第一排字
 579   3            OledWriteAssic57(1, charNum * 6, *str);
 580   3              }
 581   2              else if(charNum < 32){
 582   3            OledWriteAssic57(2, (charNum - 16) * 6, *str);
 583   3      
 584   3          }
 585   2          else if(charNum < 48){
 586   3            OledWriteAssic57(3, (charNum - 32) * 6, *str);
 587   3      
 588   3          }
 589   2          else if(charNum < 64){
 590   3            OledWriteAssic57(4, (charNum - 48) * 6, *str);
 591   3      
 592   3          }
 593   2          else
 594   2            break;
 595   2          str++;
 596   2          charNum++;
 597   2        }
 598   1        /*
 599   1        while(1){
 600   1      
 601   1          if(charNum < 16){     //第一排字
 602   1            OledWriteAssic57(1, charNum * 6, ' ');
 603   1              }
 604   1              else if(charNum < 32){
 605   1            OledWriteAssic57(2, (charNum - 16) * 6, ' ');
C51 COMPILER V9.52.0.0   STC15_OLED                                                        06/08/2016 09:44:05 PAGE 11  

 606   1      
 607   1          }
 608   1          else if(charNum < 48){
 609   1            OledWriteAssic57(3, (charNum - 32) * 6, ' ');
 610   1      
 611   1          }
 612   1          else if(charNum < 64){
 613   1            OledWriteAssic57(4, (charNum - 48) * 6, ' ');
 614   1      
 615   1          }
 616   1          else
 617   1            break;
 618   1          charNum++;
 619   1          }
 620   1          */
 621   1      }
 622          
 623          /*
 624            功能 : 清除某行某列开始的值
 625            输入 : Page 和 Col 的位置
 626          */
 627          char clearPageCol(unsigned char Page, unsigned char Col)
 628          {
 629   1        unsigned char i = Col;
 630   1      
 631   1        if(Page > 4 || Col > MAX_COLUMN)
 632   1          return 1;
 633   1        SetStartPage(Page);         //SetPageAddress(page); 
 634   1          SetStartColumn(Col);
 635   1        for(; i < MAX_COLUMN; i++){
 636   2          WR1BData(0);
 637   2        }
 638   1        return 0;
 639   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2870    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      48
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
